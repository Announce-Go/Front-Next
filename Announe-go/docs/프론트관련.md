개발환경 Next + Typescript + tailwind + shadcn UI

---

## 보이스톤 (Voice Tone)

**모든 UI 텍스트는 "해요체"를 사용한다.**

| 구분 | 잘못된 예 | 올바른 예 |
|------|---------|---------|
| 버튼 | 로그인, 저장, 확인 | 로그인해요, 저장해요 → 단어형은 그대로, 문장형만 해요체 |
| placeholder | 아이디를 입력하십시오 | 아이디를 입력해 주세요 |
| 에러 메시지 | 로그인 실패. 다시 시도하라 | 로그인에 실패했어요. 아이디/비밀번호를 확인해 주세요 |
| 성공 메시지 | 저장 완료 | 저장되었어요 |
| 안내 문구 | 계정이 없습니까? | 계정이 없으신가요? |
| 로딩 문구 | 처리중 | 처리 중이에요... |
| 빈 상태 | 데이터 없음 | 아직 데이터가 없어요 |
| 재시도 | 다시 시도 | 다시 시도해 주세요 |

### 핵심 원칙
- 버튼 라벨 단독 단어 (로그인, 저장, 삭제 등)는 그대로 유지
- **문장 형태의 모든 텍스트**는 반드시 해요체 적용
- 딱딱한 명령형(`~하라`, `~하십시오`) 금지
- 과도하게 귀여운 말투(`~해용`, `~할게욥`) 금지

---

## Next.js 권장 패턴

### 1. Server Component vs Client Component

| 기준 | Server Component (기본) | Client Component (`"use client"`) |
|------|------------------------|----------------------------------|
| 데이터 페칭 | `async/await` 직접 사용 | React Query (`useQuery`) |
| 상태 관리 | 불가 | useState, useReducer |
| 브라우저 API | 불가 | 가능 |
| 이벤트 핸들러 | 불가 | onClick, onChange 등 |
| 성능 | 번들 크기 줄어듦 (기본 권장) | 필요한 경우에만 사용 |

```
// 페이지 구조 권장 패턴
page.tsx (Server Component)
  └── 데이터 페칭 (async/await)
  └── ClientWrapper.tsx ("use client") — 인터랙션 필요한 부분만
```

### 2. 데이터 페칭 패턴

#### 서버 컴포넌트에서 (초기 데이터 / SEO 필요)
```tsx
// app/agency/place-rank/page.tsx
export default async function PlaceRankPage() {
  const data = await serverFetch<ResponseType>("/api/v1/place-rank")
  return <PlaceRankClient initialData={data} />
}
```

#### 클라이언트에서 (인터랙션 / 실시간 갱신)
```tsx
"use client"
import { useQuery } from "@tanstack/react-query"

const { data, isLoading, isError } = useQuery({
  queryKey: ["place-rank"],
  queryFn: () => http.get("/api/v1/place-rank").then(r => r.data),
})
```

### 3. 라우팅 패턴

- `router.push()` — 페이지 이동 (히스토리 추가)
- `router.replace()` — 페이지 이동 (히스토리 교체, 로그인 후 redirect 등)
- `redirect()` — 서버 컴포넌트에서 redirect
- `<Link href="...">` — 정적 링크 (prefetch 자동)

```tsx
// 로그인 후 이동: replace 권장 (뒤로가기 방지)
router.replace("/agency/dashboard")

// 일반 이동: push
router.push("/agency/place-rank")
```

### 4. 폼 처리 패턴

항상 `react-hook-form` + `zod` 조합 사용.

```tsx
const formSchema = z.object({
  name: z.string().min(1, { message: "이름을 입력해 주세요" }),
})

const form = useForm<z.infer<typeof formSchema>>({
  resolver: zodResolver(formSchema),
  defaultValues: { name: "" },
})
```

### 5. 에러 핸들링 패턴

- 서버 컴포넌트 에러: `error.tsx` (Next.js 내장)
- 클라이언트 에러: try/catch + toast + 에러 state
- 전역 에러: `app/error.tsx`

```tsx
// app/agency/error.tsx
"use client"
export default function Error({ reset }: { reset: () => void }) {
  return (
    <div className="flex flex-col items-center justify-center py-20 gap-4">
      <p className="text-slate-400">문제가 발생했어요.</p>
      <button onClick={reset} className="text-cyan-400 text-sm">다시 시도해 주세요</button>
    </div>
  )
}
```

### 6. 레이아웃 패턴

- 공통 레이아웃: `layout.tsx`에서 처리
- 역할별 레이아웃 그룹: `(admin)`, `(agency)`, `(advertiser)` 폴더
- 인증 필요 페이지: layout에서 서버사이드 세션 체크

```tsx
// app/agency/layout.tsx
export default async function AgencyLayout({ children }) {
  const session = await getServerSession()
  if (!session) redirect("/login")
  return <div>{children}</div>
}
```

### 7. 이미지 처리

항상 `next/image` 사용 (일반 `<img>` 태그 금지)

```tsx
import Image from "next/image"
<Image src="/logo.png" alt="모두보고 로고" width={80} height={80} />
```

### 8. 메타데이터

각 페이지에 `metadata` export 또는 `generateMetadata` 사용

```tsx
export const metadata = {
  title: "플레이스 순위 | 모두보고",
  description: "실시간 플레이스 순위를 확인해 보세요",
}
```

---

## 필수 규칙: 로딩 & 에러 피드백

모든 비동기 작업(API 호출, 데이터 페칭 등)에는 반드시 사용자 피드백을 제공해야 한다.
**로딩과 에러 처리를 빠뜨리는 것은 금지.**

---

### 로딩 상태

| 상황 | 처리 방법 |
|------|---------|
| 페이지 전체 데이터 로딩 | 스켈레톤 UI (Skeleton) |
| 버튼 클릭 후 API 대기 | 버튼 내 스피너 + 텍스트 변경 + disabled |
| 목록/테이블 로딩 | 스켈레톤 행(row) 반복 |
| 카드 로딩 | 스켈레톤 카드 |
| 이미지 로딩 | 스켈레톤 또는 blur placeholder |

#### 스피너 패턴 (버튼 내부)
```tsx
{isLoading ? (
  <div className="flex items-center gap-2">
    <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
    처리 중이에요...
  </div>
) : "확인"}
```

#### 스켈레톤 패턴 (shadcn Skeleton 컴포넌트 사용)
```tsx
import { Skeleton } from "@/components/ui/skeleton"

// 카드 스켈레톤
<div className="space-y-3">
  <Skeleton className="h-[48px] w-full rounded-xl" />
  <Skeleton className="h-[48px] w-full rounded-xl" />
  <Skeleton className="h-[48px] w-3/4 rounded-xl" />
</div>

// 테이블 행 스켈레톤
{Array.from({ length: 5 }).map((_, i) => (
  <Skeleton key={i} className="h-12 w-full rounded-lg" />
))}
```

---

### 에러 상태

| 상황 | 처리 방법 |
|------|---------|
| 폼 제출 실패 (서버 에러) | 폼 하단 에러 박스 표시 |
| 페이지 데이터 로딩 실패 | 에러 메시지 + 재시도 버튼 |
| 토스트 알림 | sonner 라이브러리 사용 |

#### 에러 박스 패턴 (현재 UI 테마 기준)
```tsx
{errorMessage && (
  <div className="rounded-xl p-3 border"
    style={{
      background: "rgba(239,68,68,0.1)",
      borderColor: "rgba(239,68,68,0.3)",
    }}
  >
    <p className="text-sm text-red-400 text-center">{errorMessage}</p>
  </div>
)}
```

#### 토스트 패턴 (sonner)
```tsx
import { toast } from "sonner"

toast.success("저장되었어요.")
toast.error("오류가 발생했어요. 다시 시도해 주세요.")
toast.loading("처리 중이에요...")
```

#### 페이지 레벨 에러 패턴
```tsx
if (isError) {
  return (
    <div className="flex flex-col items-center justify-center py-20 gap-4">
      <p className="text-slate-400">데이터를 불러오지 못했어요.</p>
      <button onClick={() => refetch()} className="text-cyan-400 hover:opacity-80 text-sm">
        다시 시도해 주세요
      </button>
    </div>
  )
}
```

---

### React Query 사용 시 기본 패턴

```tsx
const { data, isLoading, isError, refetch } = useQuery({ ... })

if (isLoading) return <스켈레톤 />
if (isError) return <에러 UI />
return <실제 컴포넌트 data={data} />
```

---

### 체크리스트 (작업 전 확인)

- [ ] 데이터 페칭 중 스켈레톤 또는 스피너를 표시했나요?
- [ ] API 실패 시 사용자에게 에러 메시지를 표시했나요?
- [ ] 버튼 클릭 후 응답 대기 중 disabled + 로딩을 표시했나요?
- [ ] 성공/실패 시 toast 피드백을 제공했나요?
- [ ] 모든 문장형 텍스트에 해요체를 적용했나요?
- [ ] Server/Client Component 구분이 적절한가요?
- [ ] `<Link>` 또는 `router.push/replace` 를 상황에 맞게 사용했나요?
